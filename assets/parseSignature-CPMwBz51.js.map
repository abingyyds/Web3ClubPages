{"version":3,"file":"parseSignature-CPMwBz51.js","sources":["../../node_modules/viem/_esm/utils/abi/encodePacked.js","../../node_modules/viem/_esm/utils/nonceManager.js","../../node_modules/viem/_esm/constants/bytes.js","../../node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js","../../node_modules/viem/_esm/utils/signature/parseSignature.js"],"sourcesContent":["import { AbiEncodingLengthMismatchError, BytesSizeMismatchError, UnsupportedPackedAbiType, } from '../../errors/abi.js';\nimport { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concatHex } from '../data/concat.js';\nimport { pad } from '../data/pad.js';\nimport { boolToHex, numberToHex, stringToHex, } from '../encoding/toHex.js';\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js';\nexport function encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new AbiEncodingLengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encode(type, value));\n    }\n    return concatHex(data);\n}\nfunction encode(type, value, isArray = false) {\n    if (type === 'address') {\n        const address = value;\n        if (!isAddress(address))\n            throw new InvalidAddressError({ address });\n        return pad(address.toLowerCase(), {\n            size: isArray ? 32 : null,\n        });\n    }\n    if (type === 'string')\n        return stringToHex(value);\n    if (type === 'bytes')\n        return value;\n    if (type === 'bool')\n        return pad(boolToHex(value), { size: isArray ? 32 : 1 });\n    const intMatch = type.match(integerRegex);\n    if (intMatch) {\n        const [_type, baseType, bits = '256'] = intMatch;\n        const size = Number.parseInt(bits, 10) / 8;\n        return numberToHex(value, {\n            size: isArray ? 32 : size,\n            signed: baseType === 'int',\n        });\n    }\n    const bytesMatch = type.match(bytesRegex);\n    if (bytesMatch) {\n        const [_type, size] = bytesMatch;\n        if (Number.parseInt(size, 10) !== (value.length - 2) / 2)\n            throw new BytesSizeMismatchError({\n                expectedSize: Number.parseInt(size, 10),\n                givenSize: (value.length - 2) / 2,\n            });\n        return pad(value, { dir: 'right', size: isArray ? 32 : null });\n    }\n    const arrayMatch = type.match(arrayRegex);\n    if (arrayMatch && Array.isArray(value)) {\n        const [_type, childType] = arrayMatch;\n        const data = [];\n        for (let i = 0; i < value.length; i++) {\n            data.push(encode(childType, value[i], true));\n        }\n        if (data.length === 0)\n            return '0x';\n        return concatHex(data);\n    }\n    throw new UnsupportedPackedAbiType(type);\n}\n//# sourceMappingURL=encodePacked.js.map","import { getTransactionCount } from '../actions/public/getTransactionCount.js';\nimport { LruMap } from './lru.js';\n/**\n * Creates a nonce manager for auto-incrementing transaction nonces.\n *\n * - Docs: https://viem.sh/docs/accounts/createNonceManager\n *\n * @example\n * ```ts\n * const nonceManager = createNonceManager({\n *   source: jsonRpc(),\n * })\n * ```\n */\nexport function createNonceManager(parameters) {\n    const { source } = parameters;\n    const deltaMap = new Map();\n    const nonceMap = new LruMap(8192);\n    const promiseMap = new Map();\n    const getKey = ({ address, chainId }) => `${address}.${chainId}`;\n    return {\n        async consume({ address, chainId, client }) {\n            const key = getKey({ address, chainId });\n            const promise = this.get({ address, chainId, client });\n            this.increment({ address, chainId });\n            const nonce = await promise;\n            await source.set({ address, chainId }, nonce);\n            nonceMap.set(key, nonce);\n            return nonce;\n        },\n        async increment({ address, chainId }) {\n            const key = getKey({ address, chainId });\n            const delta = deltaMap.get(key) ?? 0;\n            deltaMap.set(key, delta + 1);\n        },\n        async get({ address, chainId, client }) {\n            const key = getKey({ address, chainId });\n            let promise = promiseMap.get(key);\n            if (!promise) {\n                promise = (async () => {\n                    try {\n                        const nonce = await source.get({ address, chainId, client });\n                        const previousNonce = nonceMap.get(key) ?? 0;\n                        if (previousNonce > 0 && nonce <= previousNonce)\n                            return previousNonce + 1;\n                        nonceMap.delete(key);\n                        return nonce;\n                    }\n                    finally {\n                        this.reset({ address, chainId });\n                    }\n                })();\n                promiseMap.set(key, promise);\n            }\n            const delta = deltaMap.get(key) ?? 0;\n            return delta + (await promise);\n        },\n        reset({ address, chainId }) {\n            const key = getKey({ address, chainId });\n            deltaMap.delete(key);\n            promiseMap.delete(key);\n        },\n    };\n}\n/** JSON-RPC source for a nonce manager. */\nexport function jsonRpc() {\n    return {\n        async get(parameters) {\n            const { address, client } = parameters;\n            return getTransactionCount(client, {\n                address,\n                blockTag: 'pending',\n            });\n        },\n        set() { },\n    };\n}\n////////////////////////////////////////////////////////////////////////////////////////////\n// Default\n/** Default Nonce Manager with a JSON-RPC source. */\nexport const nonceManager = /*#__PURE__*/ createNonceManager({\n    source: jsonRpc(),\n});\n//# sourceMappingURL=nonceManager.js.map","export const erc6492MagicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\nexport const zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';\n//# sourceMappingURL=bytes.js.map","import { erc6492MagicBytes } from '../../constants/bytes.js';\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js';\nimport { concatHex } from '../data/concat.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\n/**\n * @description Serializes a ERC-6492 flavoured signature into hex format.\n *\n * @param signature ERC-6492 signature in object format.\n * @returns ERC-6492 signature in hex format.\n *\n * @example\n * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })\n * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n */\nexport function serializeErc6492Signature(parameters) {\n    const { address, data, signature, to = 'hex' } = parameters;\n    const signature_ = concatHex([\n        encodeAbiParameters([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], [address, data, signature]),\n        erc6492MagicBytes,\n    ]);\n    if (to === 'hex')\n        return signature_;\n    return hexToBytes(signature_);\n}\n//# sourceMappingURL=serializeErc6492Signature.js.map","import { secp256k1 } from '@noble/curves/secp256k1';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * @description Parses a hex formatted signature into a structured signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', s: '0x...', v: 28n }\n */\nexport function parseSignature(signatureHex) {\n    const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));\n    const yParityOrV = Number(`0x${signatureHex.slice(130)}`);\n    const [v, yParity] = (() => {\n        if (yParityOrV === 0 || yParityOrV === 1)\n            return [undefined, yParityOrV];\n        if (yParityOrV === 27)\n            return [BigInt(yParityOrV), 0];\n        if (yParityOrV === 28)\n            return [BigInt(yParityOrV), 1];\n        throw new Error('Invalid yParityOrV value');\n    })();\n    if (typeof v !== 'undefined')\n        return {\n            r: numberToHex(r, { size: 32 }),\n            s: numberToHex(s, { size: 32 }),\n            v,\n            yParity,\n        };\n    return {\n        r: numberToHex(r, { size: 32 }),\n        s: numberToHex(s, { size: 32 }),\n        yParity,\n    };\n}\n//# sourceMappingURL=parseSignature.js.map"],"names":["encodePacked","types","values","AbiEncodingLengthMismatchError","data","i","type","value","encode","concatHex","isArray","address","isAddress","InvalidAddressError","pad","stringToHex","boolToHex","intMatch","integerRegex","_type","baseType","bits","size","numberToHex","bytesMatch","bytesRegex","BytesSizeMismatchError","arrayMatch","arrayRegex","childType","UnsupportedPackedAbiType","createNonceManager","parameters","source","deltaMap","nonceMap","LruMap","promiseMap","getKey","chainId","client","key","promise","nonce","delta","previousNonce","erc6492MagicBytes","serializeErc6492Signature","signature","to","signature_","encodeAbiParameters","hexToBytes","parseSignature","signatureHex","r","s","secp256k1","yParityOrV","v","yParity"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}