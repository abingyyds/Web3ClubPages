{"version":3,"file":"ExchangeController-BIGxZ0dh.js","sources":["../../node_modules/.pnpm/@reown+appkit-controllers@1.8.9_@types+react@18.3.26_bufferutil@4.0.9_react@18.3.1_typescript_blveqq2sokyi6g3qyd7v3fqxee/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ExchangeController.js"],"sourcesContent":["import { proxy, subscribe as sub } from 'valtio/vanilla';\nimport { subscribeKey as subKey } from 'valtio/vanilla/utils';\nimport { NumberUtil } from '@reown/appkit-common';\nimport { getActiveNetworkTokenAddress } from '../utils/ChainControllerUtil.js';\nimport { ConstantsUtil } from '../utils/ConstantsUtil.js';\nimport { CoreHelperUtil } from '../utils/CoreHelperUtil.js';\nimport { formatCaip19Asset, getBuyStatus, getExchanges, getPayUrl, getPaymentAssetsForNetwork } from '../utils/ExchangeUtil.js';\nimport { BlockchainApiController } from './BlockchainApiController.js';\nimport { ChainController } from './ChainController.js';\nimport { EventsController } from './EventsController.js';\nimport { OptionsController } from './OptionsController.js';\nimport { SnackController } from './SnackController.js';\n// -- Constants ----------------------------------------- //\nconst DEFAULT_PAGE = 0;\nexport const DEFAULT_STATE = {\n    paymentAsset: null,\n    amount: null,\n    tokenAmount: 0,\n    priceLoading: false,\n    error: null,\n    exchanges: [],\n    isLoading: false,\n    currentPayment: undefined,\n    isPaymentInProgress: false,\n    paymentId: '',\n    assets: []\n};\n// -- State --------------------------------------------- //\nconst state = proxy(DEFAULT_STATE);\n// -- Controller ---------------------------------------- //\nexport const ExchangeController = {\n    state,\n    // -- Subscriptions ----------------------------------- //\n    subscribe(callback) {\n        return sub(state, () => callback(state));\n    },\n    subscribeKey(key, callback) {\n        return subKey(state, key, callback);\n    },\n    resetState() {\n        Object.assign(state, { ...DEFAULT_STATE });\n    },\n    async getAssetsForNetwork(network) {\n        const assets = getPaymentAssetsForNetwork(network);\n        const metadata = await ExchangeController.getAssetsImageAndPrice(assets);\n        const assetsWithPrice = assets.map(asset => {\n            const assetAddress = asset.asset === 'native'\n                ? getActiveNetworkTokenAddress()\n                : `${asset.network}:${asset.asset}`;\n            const assetMetadata = metadata.find(m => m.fungibles?.[0]?.address?.toLowerCase() === assetAddress.toLowerCase());\n            return {\n                ...asset,\n                price: assetMetadata?.fungibles?.[0]?.price || 1,\n                metadata: {\n                    ...asset.metadata,\n                    iconUrl: assetMetadata?.fungibles?.[0]?.iconUrl\n                }\n            };\n        });\n        state.assets = assetsWithPrice;\n        return assetsWithPrice;\n    },\n    async getAssetsImageAndPrice(assets) {\n        const addresses = assets.map(asset => asset.asset === 'native' ? getActiveNetworkTokenAddress() : `${asset.network}:${asset.asset}`);\n        const metadata = await Promise.all(addresses.map(address => BlockchainApiController.fetchTokenPrice({ addresses: [address] })));\n        return metadata;\n    },\n    getTokenAmount() {\n        if (!state?.paymentAsset?.price) {\n            throw new Error('Cannot get token price');\n        }\n        const bigAmount = NumberUtil.bigNumber(state.amount ?? 0).round(8);\n        const bigPrice = NumberUtil.bigNumber(state.paymentAsset.price).round(8);\n        return bigAmount.div(bigPrice).round(8).toNumber();\n    },\n    setAmount(amount) {\n        state.amount = amount;\n        if (state.paymentAsset?.price) {\n            state.tokenAmount = ExchangeController.getTokenAmount();\n        }\n    },\n    setPaymentAsset(asset) {\n        state.paymentAsset = asset;\n    },\n    isPayWithExchangeEnabled() {\n        return (OptionsController.state.remoteFeatures?.payWithExchange ||\n            OptionsController.state.remoteFeatures?.payments ||\n            OptionsController.state.features?.pay);\n    },\n    isPayWithExchangeSupported() {\n        return (ExchangeController.isPayWithExchangeEnabled() &&\n            ChainController.state.activeCaipNetwork &&\n            ConstantsUtil.PAY_WITH_EXCHANGE_SUPPORTED_CHAIN_NAMESPACES.includes(ChainController.state.activeCaipNetwork.chainNamespace));\n    },\n    // -- Getters ----------------------------------------- //\n    async fetchExchanges() {\n        try {\n            const isPayWithExchangeSupported = ExchangeController.isPayWithExchangeSupported();\n            if (!state.paymentAsset || !isPayWithExchangeSupported) {\n                state.exchanges = [];\n                state.isLoading = false;\n                return;\n            }\n            state.isLoading = true;\n            const response = await getExchanges({\n                page: DEFAULT_PAGE,\n                asset: formatCaip19Asset(state.paymentAsset.network, state.paymentAsset.asset),\n                amount: state.amount?.toString() ?? '0'\n            });\n            // Putting this here in order to maintain backawrds compatibility with the UI when we introduce more exchanges\n            state.exchanges = response.exchanges.slice(0, 2);\n        }\n        catch (error) {\n            SnackController.showError('Unable to get exchanges');\n            throw new Error('Unable to get exchanges');\n        }\n        finally {\n            state.isLoading = false;\n        }\n    },\n    async getPayUrl(exchangeId, params) {\n        try {\n            const numericAmount = Number(params.amount);\n            const response = await getPayUrl({\n                exchangeId,\n                asset: formatCaip19Asset(params.network, params.asset),\n                amount: numericAmount.toString(),\n                recipient: `${params.network}:${params.recipient}`\n            });\n            EventsController.sendEvent({\n                type: 'track',\n                event: 'PAY_EXCHANGE_SELECTED',\n                properties: {\n                    exchange: {\n                        id: exchangeId\n                    },\n                    configuration: {\n                        network: params.network,\n                        asset: params.asset,\n                        recipient: params.recipient,\n                        amount: numericAmount\n                    },\n                    currentPayment: {\n                        type: 'exchange',\n                        exchangeId\n                    },\n                    source: 'fund-from-exchange',\n                    headless: false\n                }\n            });\n            return response;\n        }\n        catch (error) {\n            if (error instanceof Error && error.message.includes('is not supported')) {\n                throw new Error('Asset not supported');\n            }\n            throw new Error(error.message);\n        }\n    },\n    async handlePayWithExchange(exchangeId) {\n        try {\n            const address = ChainController.getAccountData()?.address;\n            if (!address) {\n                throw new Error('No account connected');\n            }\n            if (!state.paymentAsset) {\n                throw new Error('No payment asset selected');\n            }\n            const popupWindow = CoreHelperUtil.returnOpenHref('', 'popupWindow', 'scrollbar=yes,width=480,height=720');\n            if (!popupWindow) {\n                throw new Error('Could not create popup window');\n            }\n            state.isPaymentInProgress = true;\n            state.paymentId = crypto.randomUUID();\n            state.currentPayment = {\n                type: 'exchange',\n                exchangeId\n            };\n            const { network, asset } = state.paymentAsset;\n            const payUrlParams = {\n                network,\n                asset,\n                amount: state.tokenAmount,\n                recipient: address\n            };\n            const payUrl = await ExchangeController.getPayUrl(exchangeId, payUrlParams);\n            if (!payUrl) {\n                try {\n                    popupWindow.close();\n                }\n                catch (err) {\n                    // eslint-disable-next-line no-console\n                    console.error('Unable to close popup window', err);\n                }\n                throw new Error('Unable to initiate payment');\n            }\n            state.currentPayment.sessionId = payUrl.sessionId;\n            state.currentPayment.status = 'IN_PROGRESS';\n            state.currentPayment.exchangeId = exchangeId;\n            popupWindow.location.href = payUrl.url;\n        }\n        catch (error) {\n            state.error = 'Unable to initiate payment';\n            SnackController.showError(state.error);\n        }\n    },\n    async waitUntilComplete({ exchangeId, sessionId, paymentId, retries = 20 }) {\n        const status = await ExchangeController.getBuyStatus(exchangeId, sessionId, paymentId);\n        if (status.status === 'SUCCESS' || status.status === 'FAILED') {\n            return status;\n        }\n        if (retries === 0) {\n            throw new Error('Unable to get deposit status');\n        }\n        // Wait 5 seconds before checking again\n        await new Promise(resolve => {\n            setTimeout(resolve, 5000);\n        });\n        return ExchangeController.waitUntilComplete({\n            exchangeId,\n            sessionId,\n            paymentId,\n            retries: retries - 1\n        });\n    },\n    async getBuyStatus(exchangeId, sessionId, paymentId) {\n        try {\n            if (!state.currentPayment) {\n                throw new Error('No current payment');\n            }\n            const status = await getBuyStatus({ sessionId, exchangeId });\n            state.currentPayment.status = status.status;\n            if (status.status === 'SUCCESS' || status.status === 'FAILED') {\n                const address = ChainController.getAccountData()?.address;\n                state.currentPayment.result = status.txHash;\n                state.isPaymentInProgress = false;\n                EventsController.sendEvent({\n                    type: 'track',\n                    event: status.status === 'SUCCESS' ? 'PAY_SUCCESS' : 'PAY_ERROR',\n                    properties: {\n                        message: status.status === 'FAILED' ? CoreHelperUtil.parseError(state.error) : undefined,\n                        source: 'fund-from-exchange',\n                        paymentId,\n                        configuration: {\n                            network: state.paymentAsset?.network || '',\n                            asset: state.paymentAsset?.asset || '',\n                            recipient: address || '',\n                            amount: state.amount ?? 0\n                        },\n                        currentPayment: {\n                            type: 'exchange',\n                            exchangeId: state.currentPayment?.exchangeId,\n                            sessionId: state.currentPayment?.sessionId,\n                            result: status.txHash\n                        }\n                    }\n                });\n            }\n            return status;\n        }\n        catch (error) {\n            return {\n                status: 'UNKNOWN',\n                txHash: ''\n            };\n        }\n    },\n    reset() {\n        state.currentPayment = undefined;\n        state.isPaymentInProgress = false;\n        state.paymentId = '';\n        state.paymentAsset = null;\n        state.amount = 0;\n        state.tokenAmount = 0;\n        state.priceLoading = false;\n        state.error = null;\n        state.exchanges = [];\n        state.isLoading = false;\n    }\n};\n//# sourceMappingURL=ExchangeController.js.map"],"names":["DEFAULT_PAGE","DEFAULT_STATE","state","proxy","ExchangeController","callback","sub","key","subKey","network","assets","getPaymentAssetsForNetwork","metadata","assetsWithPrice","asset","assetAddress","getActiveNetworkTokenAddress","assetMetadata","m","_c","_b","_a","_d","addresses","address","BlockchainApiController","bigAmount","NumberUtil","bigPrice","amount","OptionsController","ChainController","ConstantsUtil","isPayWithExchangeSupported","response","getExchanges","formatCaip19Asset","SnackController","exchangeId","params","numericAmount","getPayUrl","EventsController","error","popupWindow","CoreHelperUtil","payUrlParams","payUrl","err","sessionId","paymentId","retries","status","resolve","getBuyStatus","_e"],"mappings":"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","x_google_ignoreList":[0]}